<template>
    <div class="sm-tree-view-wrapper custom">
        <san-tree-view
            treeData="{=treeData=}"
            compact="{{!0}}"
            wholeLineSelected="{{!0}}"
            keepingSelected="{{!0}}"
            filterBar="{{!0}}"
            filterBarHintText="Type to find component, Enter to highlight"
            initiallyOpen="{{!0}}"
            primaryTogglesNestedTreeView="{{!0}}"
            dataSource="JSON"
            on-nestedItemToggle="nestedItemToggle($event)"
        >
            <div class="sm-tree-view-item-wrapper">
                <san-tree-view-item
                    san-for="item, index in treeData"
                    initiallyOpen="{{!0}}"
                    primaryTogglesNestedTreeView="{{!0}}"
                    treeData="{=item=}"
                    dataSource="JSON"
                    on-selectedToggle="selectedToggle($event)"
                    on-click="click($event)"
                >
                </san-tree-view-item>
            </div>
        </san-tree-view>
    </div>
</template>

<script>
import Messenger from 'chrome-ext-messenger';
import Icon from 'san-mui/lib/Icon';
import Divider from 'san-mui/lib/Divider'

import components from '../../../js/host/components';
import {TreeView, TreeViewItem} from '../../ui/mui/TreeView';

import 'san-mui/lib/index.css';
import 'san-mui/lib/Divider/Divider.styl';

import '../../ui/mui/TreeView/index.styl';
import '../../ui/mui/TreeView/custom.styl';

export default {

    components: {
        'san-icon': Icon,
        'san-tree-view': TreeView,
        'san-tree-view-item': TreeViewItem,
        'san-divider': Divider
    },

    initData() {
    },

    messages: {
        'EVENT:mouseover'(arg) {
            let evt = arg.value;
            if (!evt || !evt.comp || typeof evt.comp !== 'object') {
                return;
            }
            let data = evt.comp.data.get('secondaryText');
            if (!data) {
                return;
            }
            this.mouseOverConnection.sendMessage(
                'content_script:highlight_dom', {id: data}, () => {});
        },
        'EVENT:mouseout'(arg) {
            let evt = arg.value;
            if (!evt || !evt.comp || typeof evt.comp !== 'object') {
                return;
            }
            let data = evt.comp.data.get('secondaryText');
            if (!data) {
                return;
            }
            this.mouseOutConnection.sendMessage(
                'content_script:unhighlight_dom', {id: data}, () => {});
        }
    },

    compiled() {
        this.pageEval = chrome.devtools.inspectedWindow.eval;
        this.messenger = new Messenger();
        this.mouseOverConnection = this.messenger.initConnection(
            'component_item_mouseover', () => {});
        this.mouseOutConnection = this.messenger.initConnection(
            'component_item_mouseout', () => {});
    },

    inited() {
        this.pageEval('window.' + SAN_DEVTOOL + '.highlighter.init()');
        this.pageEval('window.' + SAN_DEVTOOL + '.san', (res, ex) => {
            if (!res) {
                return;
            }
            let connection = this.messenger.initConnection(
                'component_tree',
                (message, from, sender, sendResponse) => {
                    this.updateTreeData(message.message, message.path,
                        message.data, message.indexList);
                }
            );
        });
        this.pageEval('window.' + SAN_DEVTOOL + '.devtoolPanelCreated = true');

        this.watch('treeData', value => {

        });
    },

    created() {
        this.pageEval('window.' + SAN_DEVTOOL + '.data.treeData', (res, ex) => {
            this.data.set('treeData', res);
        });
    },

    attached() {
    },

    getDataByPathIndexList(list, root) {
        let r = root;
        let res = {
            self: null,
            selfKey: '',
            parent: null,
            parentKey: ''
        }
        for (let [i, p] of list.entries()) {
            if (!r['treeData'] || !r['treeData'][p]) {
                res.parentKey = res.parentKey.substring(1);
                res.selfKey = res.selfKey.substring(1);
                return res;
            }
            r = r['treeData'][p];
            if (i < list.length - 1) {
                res.parentKey += '.treeData[' + p + ']';
            }
            res.selfKey += '.treeData[' + p + ']';
            if (i === list.length - 2) {
                res.parent = r;
            } else if (i === list.length - 1) {
                res.self = r;
            }
        }
        !res.parent && (res.parent = root);
        res.parentKey = res.parentKey.substring(1);
        res.selfKey = res.selfKey.substring(1);
        return res;
    },

    updateTreeData(message, path, data, indexList) {
        if (!data || !path) {
            return;
        }
        if (message !== 'comp-attached' && message !== 'comp-detached') {
            return;
        }
        let root = {treeData: this.data.get('treeData')};
        let pathIndexList = components.getIndexListFromPathAndTreeData(
            path, root.treeData);
        let parentPath = path.slice(0, path.length - 1);
        switch (message) {
            case 'comp-attached': {
                for (let [i, p] of path.entries()) {
                    let currentIndexList = indexList.slice(0, i + 1);
                    let code = 'window.' + SAN_DEVTOOL + '.data'; 
                    for (let index of currentIndexList) {
                        code += '.treeData[' + index + ']';
                    }
                    // 偷懒的做法，直接从页面上下文的原始组件树中获取数据。
                    (() => {
                        this.pageEval(code, (res, ex) => {
                            if (!res || typeof res !== 'object') {
                                return;
                            }
                            const root = {treeData: this.data.get('treeData')};
                            const data = this.getDataByPathIndexList(
                                currentIndexList, root);
                            if (!data.parentKey) {
                                data.parentKey = 'treeData';
                            }
                            if (!data.selfKey) {
                                data.selfKey = 'treeData['
                                    + currentIndexList[0] + ']';
                            }
                            if (this.data.get(data.parentKey)
                                && !this.data.get(data.selfKey)) {
                                this.data.push(data.parentKey, res);
                            }
                        });
                    })(currentIndexList);
                }
                break;
            }
            case 'comp-detached': {
                const d = this.getDataByPathIndexList(pathIndexList, root);
                if (d.self && d.parent) {
                    this.data.removeAt(d.parentKey + '.treeData',
                        pathIndexList[pathIndexList.length - 1]);
                }
                break;
            }
            case 'comp-updated': {
                break;
            }
        }
    },

    nestedTreeViewToggle(value) {
        console.log(value ? 'expanding' : 'collapsing');
    },

    selectedToggle(value, text) {
        console.log(value ? 'selected' : 'unselected', text);
    },

    click(evt) {
        console.log('treeview click', evt);
    }
}
</script>

<style lang="stylus">
.sm-tree-view-wrapper
    width: 100%
    height: 100%
    .sm-tree-view
        height: 100%
        .sm-tree-view-item-wrapper
            height: calc(100% - 34px)
            overflow: auto
            .sm-tree-view-item
                .sm-touch-ripple.selected:hover
                    &~.sm-tree-view-item-content.selected
                        .sm-tree-view-item-primary-text
                            background-image: linear-gradient(to right, #c96 calc(100% - 40px), transparent);
                .sm-tree-view-item-content
                    .sm-tree-view-item-primary-text
                    &:hover
                        font-family: 'Consolas'
                        font-size: 1.2em
                        font-weight: bold
                        color: #c96
                        width: 100%;
                        background-image: linear-gradient(to right, #c96 calc(100% - 40px), transparent);
                        -webkit-background-clip: text;
                        -webkit-text-fill-color: transparent;
                        background-size: calc(100% - 80px) auto;
                        background-repeat-x: no-repeat;
                    &.selected
                        .sm-tree-view-item-primary-text
                            background-image: linear-gradient(90deg,#fff calc(100% - 40px),transparent);

    .sm-text-field
        .sm-text-field-hint
            width: 100%
            white-space: nowrap
            text-overflow: ellipsis
            overflow: hidden
    .sm-tree-view-container
        width: 100%
        overflow: auto
        position: absolute
        top: 34px
        bottom: 0
</style>
